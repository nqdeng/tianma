<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8" />
<title>天马HTTP服务器套件使用手册</title>
<style>
body {
font-family: Tahoma;
font-size: 10pt;
line-height: 170%;
padding: 0 10pt;
}

nav {
background: gray;
color: white;
overflow-x: hidden;
overflow-y: auto;
position: fixed;
top: 0;
left: 0;
bottom: 0;
width: 240px;
}

header {
padding-left: 240px;
}

header h1 {
color: #17365d;
font-size: 18pt;
font-weight: normal;
margin: 0;
padding: 0.5em 0;
text-align: right;
}

article {
padding-left: 240px;
}

article h2 {
border-bottom: dotted 1px #777;
color: #4f81bd;
font-size: 11pt;
margin: 1em 0;
padding: 0 0 0.3em 0;
}

article h3 {
color: #000;
font-size: 11pt;
margin: 1em 0;
padding: 0;
}

article h4 {
color: #000;
font-size: 10pt;
margin: 1em 0;
padding: 0;
}

article p {
margin: 1em 0;
}

article p code {
border: 1px solid #ccc;
color: #d14;
}

article p strong {
color: #f00;
}

article pre {
background: #eee;
border-left: solid 2px #3c0;
color: #000;
margin: 1em 0;
padding: 0 0 0 2em;
}

article blockquote {
background: #fff;
border: dashed 1px #777;
border-left: solid 2px #777;
color: #000;
margin: 0;
padding: 0 0 0 2em;
}

nav ul {
margin: 10px;
padding: 0;
}

nav a {
color: white;
text-decoration: none;
}

nav a:hover {
text-decoration: underline;
}

nav li {
list-style: none;
margin: 0;
padding: 0;
}

nav .level2 {
font-size: 11pt;
font-weight: bold;
}

nav .level3 {
padding-left: 1em;
}

nav .level3:before { 
content: "» ";
}

nav .level4 {
padding-left: 2em;
}

nav .level4:before { 
content: "› ";
}

footer {
border-top: 1px solid #ccc;
font-size: 10pt;
margin-top: 4em;
padding-left: 240px;
}
</style>
</head>
<body>
<header>
<h1 id="-http-">天马HTTP服务器套件使用手册</h1>

</header>
<nav>
<ul>
<li class="level2"><a href="#1">入门</a></li><li class="level3"><a href="#1.1">安装</a></li><li class="level3"><a href="#1.2">使用</a></li><li class="level4"><a href="#1.2.1">工作目录</a></li><li class="level4"><a href="#1.2.2">配置文件</a></li><li class="level4"><a href="#1.2.3">启动和停止服务</a></li><li class="level4"><a href="#1.2.4">快捷服务</a></li><li class="level2"><a href="#2">配置文件</a></li><li class="level3"><a href="#2.1">创建主机</a></li><li class="level4"><a href="#2.1.1">端口监听</a></li><li class="level4"><a href="#2.1.2">SSL证书</a></li><li class="level4"><a href="#2.1.3">IP绑定</a></li><li class="level4"><a href="#2.1.4">编码</a></li><li class="level3"><a href="#2.2">配置服务</a></li><li class="level3"><a href="#2.3">启动服务</a></li><li class="level3"><a href="#2.4">停止服务</a></li><li class="level2"><a href="#3">内置模块</a></li><li class="level3"><a href="#3.1">cache</a></li><li class="level4"><a href="#3.1.1">生效条件</a></li><li class="level4"><a href="#3.1.2">示例</a></li><li class="level3"><a href="#3.2">combo</a></li><li class="level4"><a href="#3.2.1">生效条件</a></li><li class="level4"><a href="#3.2.2">示例</a></li><li class="level3"><a href="#3.3">compress</a></li><li class="level4"><a href="#3.3.1">生效条件</a></li><li class="level4"><a href="#3.3.2">示例</a></li><li class="level3"><a href="#3.4">debug</a></li><li class="level4"><a href="#3.4.1">生效条件</a></li><li class="level4"><a href="#3.4.2">示例</a></li><li class="level3"><a href="#3.5">dynamic</a></li><li class="level4"><a href="#3.5.1">生效条件</a></li><li class="level4"><a href="#3.5.2">示例</a></li><li class="level3"><a href="#3.6">modular</a></li><li class="level4"><a href="#3.6.1">生效条件</a></li><li class="level4"><a href="#3.6.2">示例</a></li><li class="level3"><a href="#3.7">pipe</a></li><li class="level4"><a href="#3.7.1">生效条件</a></li><li class="level4"><a href="#3.7.2">示例</a></li><li class="level3"><a href="#3.8">proxy</a></li><li class="level4"><a href="#3.8.1">生效条件</a></li><li class="level4"><a href="#3.8.2">示例</a></li><li class="level3"><a href="#3.9">redirect</a></li><li class="level4"><a href="#3.9.1">生效条件</a></li><li class="level4"><a href="#3.9.2">示例</a></li><li class="level3"><a href="#3.10">refine</a></li><li class="level4"><a href="#3.10.1">生效条件</a></li><li class="level4"><a href="#3.10.2">示例</a></li><li class="level3"><a href="#3.11">static</a></li><li class="level4"><a href="#3.11.1">生效条件</a></li><li class="level4"><a href="#3.11.2">示例</a></li><li class="level2"><a href="#4">三方模块</a></li><li class="level3"><a href="#4.1">目录结构</a></li><li class="level3"><a href="#4.2">模块的加载</a></li><li class="level3"><a href="#4.3">模块的编写</a></li><li class="level4"><a href="#4.3.1">异常处理</a></li><li class="level3"><a href="#4.4">开发流程</a></li><li class="level3"><a href="#4.5">使用流程</a></li><li class="level2"><a href="#5">云配置</a></li><li class="level3"><a href="#5.1">使用方法</a></li><li class="level3"><a href="#5.2">编写方法</a></li><li class="level2"><a href="#6">SSL证书</a></li><li class="level3"><a href="#6.1">证书制作</a></li><li class="level4"><a href="#6.1.1">安装根证书</a></li><li class="level4"><a href="#6.1.2">安装OpenSSL</a></li><li class="level3"><a href="#6.2">SNI</a></li><li class="level4"><a href="#6.2.1">降级方案</a></li></ul>

</nav>
<article>
<h2 id="1">入门</h2>
<p>当前端工程师需要一个HTTP服务器来辅助开发或自娱自乐时，有以下选择——</p>
<pre><code>Apache     PHP 
   Nginx   Java
IIS  .NET  ...</code></pre>
<p>但如果你觉得以上技术要么太重、要么太难、要么不好玩的时候，请试试看基于NodeJS的天马HTTP服务器套件（以下简称天马）。</p>
<p>天马构建在基于路由器和流水线的HTTP处理模型之上，不但提供静态服务、模板渲染、反向代理、请求合并、缓存、HTTP压缩等内置模块，还提供了简单易懂的三方模块编写机制，允许前端快速定制各种HTTP服务器。</p>
<h3 id="1.1">安装</h3>
<p>首先请安装NodeJS <strong>0.10.0</strong>以上版本，然后在终端下使用以下命令安装天马。</p>
<pre><code>$ npm install tianma -g</code></pre>
<h3 id="1.2">使用</h3>
<p>安装好天马后，可以在终端下通过<code>tianma</code>命令来使用各种功能，例如查看当前版本：</p>
<pre><code>$ tianma -V
0.8.0</code></pre>
<h4 id="1.2.1">工作目录</h4>
<p>搭建服务器前需要准备一个工作目录，用于保存服务器配置、SSL证书、日志等文件。原则上可以手工创建工作目录，不过使用<code>tianma</code>命令会更方便些：</p>
<pre><code>$ tianma deploy /home/user/www
create : /home/user/www
...</code></pre>
<p>自动创建的工作目录内容如下：</p>
<pre><code>- www/                # 工作目录
    + certificates/   # SSL证书目录
    + htdocs/         # 网站根目录
    config.js         # 服务器默认配置文件
    readme.txt        # 说明文件</code></pre>
<h4 id="1.2.2">配置文件</h4>
<p>配置文件决定了服务器提供的功能，首先来看看默认配置文件（config.js）有什么内容。</p>
<pre><code>var tianma = require(&#39;tianma&#39;),
    pipe = tianma.pipe;

tianma
    .createHost({ port: 80 })
        .mount(&#39;/&#39;, [
            pipe.static({ root: &#39;./htdocs&#39; })
        ])
        .start();</code></pre>
<p>可以看到，对于配置天马而言，与其说是填写配置项，不如说是使用天马提供的API来编写一个NodeJS程序。</p>
<blockquote>
<p>   <strong>解惑：</strong> 细心的同学会发现<code>require(&#39;tianma&#39;)</code>有些奇怪，因为工作目录下并没有<code>tianma</code>这个三方包。其中的奥妙在于配置文件是通过<code>tianma</code>命令间接运行的，在运行前天马会通过<code>NODE_PATH</code>环境变量指定<code>tianma</code>三方包所在位置。</p>
</blockquote>
<h4 id="1.2.3">启动和停止服务</h4>
<p>服务器可以使用前台和后台两种运行模式。在工作目录下打开终端，通过以下命令可控制服务。</p>
<pre><code>$ tianma start              # 启动后台服务
[i] Service started.

$ tianma restart            # 重启当前后台服务
[i] Service killed.
[i] Service started.

$ tianma stop               # 停止后台服务
[i] Service killed.

$ tianma run                # 启动前台服务
[i] Press [Ctrl+C] to stop service..</code></pre>
<p>启动前台服务时，通过<code>console.log</code>和<code>console.error</code>输出的信息会直接打印在终端上，并且关闭当前终端窗口会停掉服务。而启动后台服务时，<code>console.log</code>的输出会被忽略，<code>console.error</code>的输出会被重定向到日志文件里，并且关闭当前终端窗口后服务依然继续运行。</p>
<p>另外，如果配置文件不叫做<code>config.js</code>，或者不位于当前工作目录下，启动服务时需要在命令后边加上配置文件的路径，例如<code>tianma start config2.js</code>。</p>
<blockquote>
<p>   <strong>注意：</strong> 由于HTTP(S)的默认端口是80和443，而*nix系统下又只有root用户能使用1024以下端口号，因此需要使用<code>sudo</code>来控制服务，例如<code>sudo tianma start</code>。</p>
</blockquote>
<h4 id="1.2.4">快捷服务</h4>
<p>使用以下命令可以指定网站根目录并使用80端口快速启动一个HTTP静态服务器。省略路径时，使用当前目录作为根目录。</p>
<pre><code>$ tianma express /home/admin/htdocs
Press [Ctrl+C] to stop service..</code></pre>
<p>想在两台机器间拷贝些文件时，就可以使用这招，通过HTTP下载的方式达到目的。</p>

<h2 id="2">配置文件</h2>
<p>天马HTTP服务器套件构建于<a href="http://nqdeng.github.io/pegasus/">天马HTTP中间件</a>之上，因此编写天马配置文件类似于使用<code>tianma</code>和<code>pegasus</code>（可选）两个三方包提供的API来编写一个NodeJS程序。</p>
<h3 id="2.1">创建主机</h3>
<p>主机是提供HTTP服务的基本单位，可以通过<code>tianma.createHost</code>方法创建。</p>
<pre><code>var host = tianma.createHost(config);</code></pre>
<h4 id="2.1.1">端口监听</h4>
<p><code>port</code>和<code>portssl</code>字段分别用于指定主机需要监听的HTTP和HTTPS端口。缺少某个字段时，主机不监听对应端口。</p>
<pre><code>tianma
    .createHost({ port: 80, portssl: 443 });</code></pre>
<h4 id="2.1.2">SSL证书</h4>
<p><code>cert</code>和<code>key</code>字段用于指定提供HTTPS服务时使用的公钥和私钥。缺少这两个字段时，默认使用天马根证书。</p>
<pre><code>tianma
    .createHost({
        cert: &#39;pathname/of/certificates.cer&#39;,  // 公钥文件路径
        key: &#39;pathname/of/certificates.key&#39;,   // 私钥文件路径
        portssl: 443,
    });</code></pre>
<p>天马服务器支持SNI技术，一般不需要手工配置这两个字段，在后边的章节中会有详细介绍。</p>
<h4 id="2.1.3">IP绑定</h4>
<p>当服务器上有多个IP时，可以通过<code>ip</code>字段指定绑定哪个IP提供服务。缺少该字段时，绑定所有IP。</p>
<pre><code>tianma
    .createHost({ ip: &#39;127.0.0.1&#39;, port: 80 });</code></pre>
<h4 id="2.1.4">编码</h4>
<p><code>charset</code>字段用于指定主机处理HTTP请求和响应时使用的编码。缺少该字段时，默认使用<code>utf-8</code>编码。</p>
<pre><code>tianma
    .createHost({ charset: &#39;gbk&#39;, port: 80 });</code></pre>
<p>天马支持的编码类型请参考<a href="https://github.com/ashtuchkin/iconv-lite#supported-encodings">iconv-lite</a>。</p>
<h3 id="2.2">配置服务</h3>
<p>主机根据路由规则，使用相应的流水线来处理HTTP请求，并在完成之后将HTTP响应返回给客户端。这一切都通过主机对象的<code>.mount</code>方法来配置。</p>
<pre><code>tianma
    .createHost({ port: 80 })
        .mount(&#39;*.example.com&#39;, [
            function (context, next) {
                context.response
                    .status(200)
                    .write(&#39;Hello World&#39;);
                next();
            }
        ])
        .mount(&#39;/&#39;, [
            function (context, next) {
                context.response
                    .status(500)
                    .write(&#39;Bad Request&#39;);
                next();
            }
        ]);</code></pre>
<blockquote>
<p>   <strong>传送门：</strong> 请查看<a href="http://nqdeng.github.io/pegasus/">天马HTTP中间件使用手册</a>学习路由规则的配置和流水线模块的编写。</p>
</blockquote>
<h3 id="2.3">启动服务</h3>
<p>通过主机对象的<code>.start</code>方法可以启动服务。存在回调函数时，服务启动后调用回调函数，并传入主机对象。</p>
<pre><code>tianma
    .createHost({ port: 80 })
        .start(function (host) {});</code></pre>
<h3 id="2.4">停止服务</h3>
<p>通过主机对象的<code>.stop</code>方法可以停止服务。存在回调函数时，服务停止后调用回调函数，并传入主机对象。</p>
<pre><code>tianma
    .createHost({ port: 80 })
        .stop(function (host) {});</code></pre>

<h2 id="3">内置模块</h2>
<p>天马提供了一些内置模块，合理组合之后能解决很多问题。内置模块使用<a href="http://nqdeng.github.io/pegasus/#3.4"><code>pegasus.createPipe</code></a>方法编写，因此在使用前需要先实例化，在处理每个请求前需要先判定生效条件。</p>
<h3 id="3.1">cache</h3>
<blockquote>
<p>   tianma.pipe.cache(pipeline, config)</p>
</blockquote>
<p>缓存模块，为HTTP GET请求提供客户端缓存支持。</p>
<ul>
<li><p>pipeline:Array = []</p>
<p>  子流水线，用于装填需要缓存响应结果的模块。</p>
</li>
<li><p>config.expires:number = 1800</p>
<p>  缓存有效期，秒单位。</p>
</li>
</ul>
<p>该模块完成以下两项工作：</p>
<ol>
<li><p>使用子流水线处理普通请求后，为GET请求的200响应头添加客户端缓存字段。</p>
</li>
<li><p>检查后续收到的条件GET请求是否在有效期内，有效时返回304响应，无效时重复第1项工作。</p>
</li>
</ol>
<h4 id="3.1.1">生效条件</h4>
<p>无限制。</p>
<h4 id="3.1.2">示例</h4>
<pre><code>tianma
    .createHost({ port: 80 })
        .mount(&#39;/&#39;, [
            tianma.pipe.cache([
                tianma.pipe.static({ root: &#39;./htdocs&#39; })
            ])
        ])
        .start();</code></pre>
<p>以上代码实现了带客户端缓存的静态文件服务器。客户端第一次请求某个URL后，收到的是指定了半小时缓存的200响应。客户端如果在半小时内第二次条件请求同一URL，收到的将是304响应，否则收到的是重新指定了缓存有效期的200响应。</p>
<h3 id="3.2">combo</h3>
<blockquote>
<p>   tianma.pipe.combo(config)</p>
</blockquote>
<p>请求合并模块，用于将多个同类型的GET请求合并为一个。</p>
<ul>
<li><p>config.source:string = &#39;loop://&lt;当前请求域名&gt;/&#39;</p>
<p>  源服务器地址，可以使用<a href="http://nqdeng.github.io/pegasus/#4.3"><code>context.request</code></a>方法支持的任何格式的地址。</p>
</li>
<li><p>config.strict:boolean = true</p>
<p>  是否不容忍任何异常的GET请求。</p>
</li>
<li><p>config.separator:Object = { &#39;.js&#39;: &#39;\n;\n&#39;, &#39;.css&#39;: &#39;\n&#39; }</p>
<p>  为不同扩展名的文件指定合并时使用的分隔符，未指定时不使用分隔符。</p>
</li>
</ul>
<p>该模块除了支持处理<code>/foo/??bar.js,baz.js</code>形式的文件合并请求外，还支持<code>/foo/bar.js</code>这种普通请求。该模块会去源服务器（例如为<code>http://localhost/</code>）读取请求的文件（例如<code>http://localhost/foo/bar.js</code>和<code>http://localhost/foo/baz.js</code>）后，使用指定的分隔符合并文件内容后返回响应。</p>
<p>当源服器在处理某个请求后返回的不是200响应时，根据配置，该模块可选择将整个合并请求视作异常，或是忽略掉部分异常后返回正常响应的内容合并结果。</p>
<h4 id="3.2.1">生效条件</h4>
<ol>
<li>传入的响应状态码等于<code>404</code>。</li>
</ol>
<p>2， 传入的请求方法等于<code>GET</code>。</p>
<ol>
<li>传入的请求不是由combo模块自身发起的。</li>
</ol>
<h4 id="3.2.2">示例</h4>
<pre><code>tianma
    .createHost({ port: 80 })
        .mount(&#39;/&#39;, [
            tianma.pipe.combo(),
            tianma.pipe.static({ root: &#39;./htdocs&#39; })
        ])
        .start();</code></pre>
<p>以上代码实现了一个静态文件合并服务器。当请求<code>http://localhost/foo/??bar.js,baz.js</code>到达combo模块后，会按照以下流程处理：</p>
<ol>
<li><p>由于使用默认配置，combo模块使用<code>loop://localhost/</code>作为源服务器，并接着发起<code>loop://localhost/foo/bar.js</code>和<code>loop://localhost/foo/baz.js</code>两个子请求。</p>
</li>
<li><p>子请求再次到达combo模块后，combo模块会忽略掉自身发起的请求。</p>
</li>
<li><p>子请求接着到达static模块被处理。</p>
</li>
<li><p>combo模块收到两个子请求的响应后依次合并内容，并最终返回响应。</p>
</li>
</ol>
<h3 id="3.3">compress</h3>
<blockquote>
<p>   tianma.pipe.compress(config)</p>
</blockquote>
<p>HTTP压缩模块，用于压缩响应体数据。</p>
<ul>
<li><p>config.extnames:Array = [ &#39;.js&#39;, &#39;.css&#39;, &#39;.html&#39; ]</p>
<p>  需要启用压缩的文件扩展名。</p>
</li>
</ul>
<h4 id="3.3.1">生效条件</h4>
<ol>
<li><p>传入的响应状态码等于<code>200</code>。</p>
</li>
<li><p>传入的请求头中包含<code>accept-encoding</code>字段，并且申明支持<code>gzip</code>或<code>deflate</code>压缩方式。</p>
</li>
<li><p>传入的响应头中包含<code>content-type</code>字段，并且其中的MIME与<code>config.extnames</code>中的某个扩展名匹配。</p>
</li>
</ol>
<h4 id="3.3.2">示例</h4>
<pre><code>tianma
    .createHost({ port: 80 })
        .mount(&#39;/&#39;, [
            tianma.pipe.static({ root: &#39;./htdocs&#39; }),
            tianma.pipe.compress()
        ])
        .start();</code></pre>
<p>以上代码实现了一个带HTTP压缩功能的静态文件服务器。</p>
<h3 id="3.4">debug</h3>
<blockquote>
<p>   tianma.pipe.debug()</p>
</blockquote>
<p>代码调试模块，用于将包裹在以下格式的注释中的调试代码反注释，使之生效。</p>
<pre><code>/*@debug
    console.log(&#39;debug&#39;);
*/</code></pre>
<h4 id="3.4.1">生效条件</h4>
<ol>
<li><p>传入的响应状态码等于<code>200</code>。</p>
</li>
<li><p>传入的响应头中包含<code>content-type</code>字段，并且其中的MIME与JS或CSS文件匹配。</p>
</li>
</ol>
<h4 id="3.4.2">示例</h4>
<pre><code>tianma
    .createHost({ port: 80 })
        .mount(&#39;/&#39;, [
            tianma.pipe.static({ root: &#39;./htdocs&#39; }),
            tianma.pipe.debug()
        ])
        .start();</code></pre>
<p>以上代码实现了一个静态文件调试服务器，可以将JS或CSS代码中的调试注释反注释掉。</p>
<h3 id="3.5">dynamic</h3>
<blockquote>
<p>   tianma.pipe.dynamic(config)</p>
</blockquote>
<p>动态内容模块，用于渲染模板。</p>
<ul>
<li><p>config.extname:string = &#39;.psp&#39;</p>
<p>  模板文件扩展名。</p>
</li>
</ul>
<p>该模块支持渲染使用类似<a href="http://www.w3school.com.cn/asp/index.asp">ASP JavaScript</a>的语法编写的模块，并部分支持<a href="http://www.w3school.com.cn/asp/asp_incfiles.asp">SSI</a>语法。以下是一个示例模板。</p>
<pre><code>&lt;!DOCTYPE html&gt;
&lt;!-- #include virtual=&quot;./head.inc&quot; --&gt;
&lt;body&gt;
&lt;dl&gt;
&lt;dt&gt;Request URL:&lt;/dt&gt;
&lt;dd&gt;&lt;% response.write(request.href); %&gt;&lt;/dd&gt;
&lt;dt&gt;Request Method:&lt;/dt&gt;
&lt;dd&gt;&lt;%= request.method %&gt;&lt;/dd&gt;
&lt;/dl&gt;
&lt;/body&gt;
&lt;/html&gt;</code></pre>
<p>在模板中，包含在<code>&lt;% %&gt;</code>之间的JS代码可以直接用变量名访问<code>context</code>对象的成员，而<code>&lt;%= xxx %&gt;</code>是<code>&lt;% response.write(xxx); %&gt;</code>的语法糖。</p>
<h4 id="3.5.1">生效条件</h4>
<ol>
<li><p>传入的响应状态码等于<code>200</code>。</p>
</li>
<li><p>传入的请求地址的扩展名与<code>config.extname</code>相同。</p>
</li>
</ol>
<h4 id="3.5.2">示例</h4>
<pre><code>tianma
    .createHost({ port: 80 })
        .mount(&#39;/&#39;, [
            function (context, next) {
                // Put template variables into context.
                next();
            },
            tianma.pipe.static({ root: &#39;./tmpl&#39; }),
            tianma.pipe.dynamic()
        ])
        .start();</code></pre>
<p>以上代码实现了一个动态服务器，可根据请求路径先准备好模块变量，再使用static模块读取模板文件，再使用dynamic模块渲染模板后输出响应。</p>
<h3 id="3.6">modular</h3>
<blockquote>
<p>   tianma.pipe.modular(config)</p>
</blockquote>
<p>JS模块化模块，遵循<a href="http://wiki.commonjs.org/wiki/CommonJS">CMD</a>规范。</p>
<ul>
<li><p>config.auto:boolean = false</p>
<p>  编写CMD模块时是否可以省略掉使用<code>define</code>函数包裹代码的步骤。</p>
</li>
</ul>
<p>该模块支持为CMD匿名模块自动加上模块ID和依赖信息。例如有<code>foo/bar.js</code>内容如下：</p>
<pre><code>define(function (require, exports, module) {
    exports.baz = require(&#39;./baz&#39;);
});</code></pre>
<p>经过modular模块转换后内容变为：</p>
<pre><code>define(&quot;foo/bar.js&quot;, [ &quot;./baz&quot; ], function (require, exports, module) {
    exports.baz = require(&#39;./baz&#39;);
});</code></pre>
<p>另外，如果<code>config.auto</code>配置为<code>true</code>，<code>foo/bar.js</code>的内容可以简写如下：</p>
<pre><code>exports.baz = require(&#39;./baz&#39;);</code></pre>
<h4 id="3.6.1">生效条件</h4>
<ol>
<li><p>传入的响应状态码等于<code>200</code>。</p>
</li>
<li><p>传入的响应头中包含<code>content-type</code>字段，并且其中的MIME与JS文件匹配。</p>
</li>
</ol>
<h4 id="3.6.2">示例</h4>
<pre><code>tianma
    .createHost({ port: 80 })
        .mount(&#39;/&#39;, [
            tianma.pipe.static({ root: &#39;./htdocs&#39; }),
            tianma.pipe.modular()
        ])
        .start();</code></pre>
<p>以上代码实现了一个CMD模块服务器，浏览器端可以使用<a href="http://seajs.org/docs/">SeaJS</a>等CMD模块管理器来加载JS模块。</p>
<h3 id="3.7">pipe</h3>
<blockquote>
<p>   tianma.pipe.pipe(pipeline)</p>
</blockquote>
<p>管道模块，用于将一个流水线转换为单个模块使用。</p>
<ul>
<li><p>pipeline:Array = []</p>
<p>  需要转换为单个模块使用的流水线。</p>
</li>
</ul>
<p>即使在同一个流水线中，有时候需要为不同的请求提供不同的处理流程，此时就可以使用该模块来简化代码的组织和编写。</p>
<h4 id="3.7.1">生效条件</h4>
<p>无限制。</p>
<h4 id="3.7.2">示例</h4>
<pre><code>var action1 = tianma.pipe.pipe([
        function (context, next) { /* Do something */ },
        function (context, next) { /* Do something */ }
    ]),

    action2 = tianma.pipe.pipe([
        function (context, next) { /* Do something */ }
    ]);

    tianma
        .createHost({ port: 80 })
            .mount(&#39;/&#39;, [
                function (context, next) {
                    if (context.request.method === &#39;GET&#39;) {
                        action1(context, next);
                    } else {
                        action2(context, next);
                    }
                }
            ])
            .start();</code></pre>
<p>以上代码根据请求方法使用了不同的处理流程。</p>
<h3 id="3.8">proxy</h3>
<blockquote>
<p>   tianma.pipe.proxy(config)</p>
</blockquote>
<p>反向代理模块，用于在服务端转发请求。</p>
<ul>
<li><p>config:Object = {}</p>
<p>  为不同的URL分别定义代理规则。</p>
</li>
</ul>
<p>可以通过键值对方式配置多组<code>target(字符串) : pattern(正则)</code>代理规则，当一个请求到达该模块时，会按以下流程处理：</p>
<ol>
<li><p>首先使用<code>url.match(pattern)</code>的方式依次使用每条代理规则匹配请求的完整URL。</p>
</li>
<li><p>如果匹配成功，使用匹配结果替换掉<code>target</code>中的<code>$n</code>占位符。</p>
</li>
<li><p>使用替换之后的<code>target</code>转发请求。</p>
</li>
</ol>
<p>另外，由于proxy模块使用<a href="http://nqdeng.github.io/pegasus/#4.3"><code>context.request</code></a>方法转发请求，因此<code>target</code>可以使用该方法支持的任何格式的地址。</p>
<h4 id="3.8.1">生效条件</h4>
<ol>
<li><p>传入的响应状态码等于<code>404</code>。</p>
</li>
<li><p>传入的请求的完整URL与某条代理规则匹配。</p>
</li>
</ol>
<h4 id="3.8.2">示例</h4>
<pre><code>tianma
    .createHost({ port: 80 })
        .mount(&#39;/&#39;, [
            tianma.pipe.static({ root: &#39;./htdocs&#39; }),
            tianma.pipe.proxy({
                &#39;http://assets.example.com/$1&#39;: /\/\/.*?\/(.*)/
            })
        ])
        .start();</code></pre>
<p>以上代码实现了一个具备服务端代理功能的静态文件服务器。当请求的文件在本地不存在时，服务器会去远程服务器读取请求的文件并返回结果。</p>
<h3 id="3.9">redirect</h3>
<blockquote>
<p>   tianma.pipe.redirect(config)</p>
</blockquote>
<p>请求重定向模块，用于在请求处理过程中更改请求路径。</p>
<ul>
<li><p>config:Object = {}</p>
<p>  为不同的路径分别定义重定向规则。</p>
</li>
</ul>
<p>可以通过键值对方式配置多组<code>target(字符串): pattern(正则)</code>代理规则，当一个请求到达该模块时，会按以下流程处理：</p>
<ol>
<li><p>首先使用<code>pathname.match(pattern)</code>的方式依次使用每条代理规则匹配请求地址的pathname部分。</p>
</li>
<li><p>如果匹配成功，使用匹配结果替换掉<code>target</code>中的<code>$n</code>占位符。</p>
</li>
<li><p>使用替换之后的<code>target</code>更新当前<code>request</code>对象中的相关字段。</p>
</li>
</ol>
<h4 id="3.9.1">生效条件</h4>
<ol>
<li><p>传入的响应状态码等于<code>404</code>。</p>
</li>
<li><p>传入的请求地址的pathname部分与某条重定向规则匹配。</p>
</li>
</ol>
<h4 id="3.9.2">示例</h4>
<pre><code>tianma
    .createHost({ port: 80 })
        .mount(&#39;/&#39;, [
            tianma.pipe.redirect({
                &#39;/new/$1&#39;: /^\/old\/(.*)$/
            }),
            tianma.pipe.static({ root: &#39;./htdocs&#39; })
        ])
        .start();</code></pre>
<p>以上代码实现了一个具备请求重定向功能的静态文件服务器，可以将对<code>/old/*</code>下所有文件的请求重定向到<code>/new/*</code>下边。</p>
<h3 id="3.10">refine</h3>
<blockquote>
<p>   tianma.pipe.refine(config)</p>
</blockquote>
<p>内容替换模块，用于替换指定类型的响应体内容。</p>
<ul>
<li><p>config:Object = {}</p>
<p>  为不同文件类型分别定义内容替换函数。</p>
</li>
</ul>
<p>该模块可以对响应体内容做一些简单替换，所有工作都需要在内容替换函数中同步完成。</p>
<h4 id="3.10.1">生效条件</h4>
<ol>
<li><p>传入的响应状态码等于<code>200</code>。</p>
</li>
<li><p>传入的响应头包含<code>content-type</code>字段，并且其中的MIME与<code>config</code>中的某个扩展名匹配。</p>
</li>
</ol>
<h4 id="3.10.2">示例</h4>
<pre><code>tianma
    .createHost({ port: 80 })
        .mount(&#39;/&#39;, [
            tianma.pipe.static({ root: &#39;./htdocs&#39; }),
            tianma.pipe.refine({
                &#39;.js&#39;: function (data) {
                    return jsmin(data);
                }
            })
        ])
        .start();</code></pre>
<p>以上代码实现了一个具备JS代码压缩功能的静态文件服务器，在refine模块中配置了JS内容替换函数并使用JSMIN来压缩代码。</p>
<h3 id="3.11">static</h3>
<blockquote>
<p>   tianma.pipe.static(config)</p>
</blockquote>
<p>静态服务模块，用于从服务器本地读取请求的文件并返回内容。</p>
<ul>
<li><p>config.autoIndex:boolean = true</p>
<p>  无默认索引文件时是否自动为目录生成索引。</p>
</li>
<li><p>config.root:string = &#39;./&#39;</p>
<p>  根目录，可以使用相对或绝对路径。</p>
</li>
<li><p>config.indexes:Array = []</p>
<p>  默认索引文件，配置了多个文件时优先级按数组索引顺序从高到低。</p>
</li>
</ul>
<p>该模块根据请求路径（pathnanme）从根目录中读取文件并返回响应。文件存在时返回200响应，否则返回404响应。当请求路径对应某个目录时，如果目录下存在默认索引文件，则改为读取默认索引文件，否则要么自动生成目录索引，要么返回403响应。</p>
<p>另外，为了避免*nix与Windows系统对文件名大小写的处理差异导致潜在问题，该模块在Windows系统下也对文件名大小写敏感。</p>
<h4 id="3.11.1">生效条件</h4>
<ol>
<li>传入的响应状态码等于<code>404</code>。</li>
</ol>
<h4 id="3.11.2">示例</h4>
<pre><code>tianma
    .createHost({ port: 80 })
        .mount(&#39;/&#39;, [
            tianma.pipe.static({
                indexes: [ &#39;index.html&#39; ], root: &#39;./htdocs&#39; })
        ])
        .start();</code></pre>
<p>以上代码实现了一个静态网站，使用<code>./htdocs</code>作为网站根目录，并使用<code>index.html</code>作为默认索引文件。</p>

<h2 id="4">三方模块</h2>
<p>当天马的内置模块无法满足需求时，可以尝试编写或使用三方模块。天马定义了一套三方模块编写规范，并借助NPM构建了三方模块生态圈系统，能够简化开发者编写和发布三方模块，也能够简化用户下载和使用三方模块。</p>
<h3 id="4.1">目录结构</h3>
<p>三方模块按以下目录结构存放在网站工作目录下。</p>
<pre><code>- www/
    + certificates/
    + htdocs/
    - node_modules/       # 三方模块存放目录
        - tianma-jsmin/   # 三方模块
            + lib/
            package.json
            ...
        ...
    config.js
    readme.txt</code></pre>
<p>可以看到，这是NodeJS三方包的标准存放方式。在编写天马三方模块时，建议使用<code>tianma-</code>作为模块名前缀，从而方便在GitHub或NPM仓库中搜索天马相关代码。</p>
<h3 id="4.2">模块的加载</h3>
<p>由于使用了<code>node_modules</code>目录存放三方模块，在配置文件中加载模块时当然可以使用<code>require(&#39;tianma-jsmin&#39;)</code>这种方式。不过天马自有一套更方便的方式。</p>
<pre><code>tianma
    .createHost({ port: 80 })
        .mount(&#39;/&#39;, [
            tianma.pipe(&#39;tianma-jsmin&#39;, { level: 1 })
        ])
        .start();</code></pre>
<p>可以看到，可以通过<code>tianma.pipe</code>方法加载三方模块。该方法要求三方模块的导出对象是一个工厂函数。工厂函数被调用时，接收传递给<code>pipe</code>方法的第2到第N个参数，并返回一个流水线模块函数。</p>
<p>另外，当<code>node_modules</code>目录下不存在指定模块时，<code>pipe</code>方法会自动调用NPM下载指定模块。如果模块名中使用<code>tianma-jsmin@1.0.0</code>的方式指定了版本号，<code>pipe</code>方法除了会下载指定版本的模块外，当<code>node_modules</code>目录下的模块与指定版本不匹配时，也会重新下载模块。</p>
<h3 id="4.3">模块的编写</h3>
<p>最简单的三方模块可以按以下方式编写：</p>
<pre><code>module.exports = function (config) {
    return function (context, next) {
        // Do something.
    };
};</code></pre>
<p>不过通常情况下我们可以使用<a href="http://nqdeng.github.io/pegasus/#3.4"><code>pegasus.createPipe</code></a>方法来简化复杂模块的编写，并使用标准的NPM目录结构来简化模块的发布和部署。</p>
<p>以<code>tianma-jsmin</code>模块为例，以下完整地说明一个标准的三方模块该怎么编写。首先是目录结构：</p>
<pre><code>- tianma-jsmin/
    - lib/
        index.js    # 入口模块
    package.json    # 包描述文件
    README.md       # 说明书</code></pre>
<p>由于该模块的功能比较简单，所有代码都可以封装在<code>index.js</code>中。如果功能再复杂一些，就需要把代码拆分到<code>lib</code>目录下的多个文件中。<code>index.js</code>内容如下：</p>
<pre><code>var jsmin = require(&#39;jsmin&#39;).jsmin,
    pegasus = require(&#39;pegasus&#39;),
    util = pegasus.util;

var CONTENT_TYPES = [
        &#39;text/javascript&#39;,
        &#39;application/x-javascript&#39;,
        &#39;application/javascript&#39;
    ];

module.exports = pegasus.createPipe({
    _initialize: function (config) {
        this._config = util.mix({
            level: 2,
            comment: &#39;&#39;
        }, config);
    },

    main: function (request, response) {
        var config = this._config,
            data = response.body();

        data = jsmin(data, config.level, config.comment);

        response
            .clear()
            .write(data);

        this.next();
    },

    match: function (request, response) {
        var contentType = response.head(&#39;content-type&#39;) || &#39;&#39;;

        return response.status() === 200
            &amp;&amp; CONTENT_TYPES.some(function (value) {
                return contentType.indexOf(value) !== -1;
            });
    }
});</code></pre>
<p><code>package.json</code>中申明了模块名、版本号、入口模块位置和依赖，内容如下：</p>
<pre><code>{
    &quot;name&quot;: &quot;tianma-jsmin&quot;,
    &quot;version&quot;: &quot;1.0.0&quot;,
    &quot;dependencies&quot;: {
        &quot;jsmin&quot;: &quot;1.0.x&quot;
      },
    &quot;main&quot;: &quot;lib/index.js&quot;
}</code></pre>
<p>有了以上目录结构和描述文件之后，该模块就可以通过NPM发布和下载了。</p>
<h4 id="4.3.1">异常处理</h4>
<p>通常情况下，流水线模块代码在运行过程中产生的未捕获异常会让服务挂掉。如果希望仅为发生异常的请求返回500响应，而让服务保持运行的话，就需要手动捕获异常并使用<a href="http://nqdeng.github.io/pegasus/#6.1"><code>pegasus.util.throwError</code></a>方法再次抛出异常。</p>
<p>例如在上边的<code>tianma-jsmin</code>模块的代码中，当JS代码有语法错误时<code>jsmin</code>方法会抛出异常。我们需要对<code>main</code>方法做出以下调整，使得有异常发生时服务不至于挂掉。</p>
<pre><code>try {
    data = jsmin(data, config.level, config.comment);
} catch (err) {
    util.throwError(err);
}</code></pre>
<p>另外，当模块代码在运行过程中发现有逻辑错误，需要主动抛出一个异常时，也需要使用<code>throwError</code>方法来代替<code>throw</code>关键字抛出异常，以保证仅仅是产生一个500响应，而不是让服务挂掉。</p>
<h3 id="4.4">开发流程</h3>
<p>开发一个三方模块时可以使用以下流程：</p>
<ol>
<li><p>使用<code>tianma deploy</code>命令部署一个工作目录，作为模块的调试环境。</p>
</li>
<li><p>在工作目录下创建<code>node_modules</code>目录，并在其中创建模块目录并编写代码。</p>
</li>
<li><p>在配置文件中使用<code>tianma.pipe</code>函数加载和调试模块。</p>
</li>
<li><p>在模块目录下使用<code>npm publish</code>命令将三方模块发布到NPM仓库。</p>
</li>
</ol>
<h3 id="4.5">使用流程</h3>
<p>使用一个三方模块时可以使用以下流程：</p>
<ol>
<li><p>在配置文件中使用<code>tianma.pipe</code>函数指定需要使用的三方模块名，以及可选的版本号，并根据需要传入模块配置。</p>
</li>
<li><p>第一次使用某个三方模块时，天马会自动调用NPM下载。在下载完成前，三方模块所在流水线暂时处于不可用状态。如果希望服务启动后立即可用，或者因为各种原因三方模块自动下载失败，就可以在工作目录下运行类似<code>npm install tianma-jsmin@1.0.0</code>的命令来手动下载模块。</p>
</li>
</ol>

<h2 id="5">云配置</h2>
<p>当同一个天马配置文件需要提供给多人使用时，每个人复制一份配置文件到自己的机器上不但麻烦，而且不利于统一维护和更新。使用云配置可以解决这个问题。</p>
<h3 id="5.1">使用方法</h3>
<p>可以按以下方式使用<code>tianma.play</code>方法加载和运行云配置。</p>
<pre><code>tianma.play(&#39;http://www.example.com/config.js&#39;);</code></pre>
<p>可以看到，云配置文件存放在某台远程服务器上。本地服务器第一次使用某个配置文件时，会先将配置文件缓存到本地后再运行。而后续使用时，如果远程服务器上的配置文件的最后修改日期未发生变化，或者连接不上远程服务器，则继续使用本地缓存的版本，否则会先更新本地缓存后再运行新的配置文件。<code>play</code>方法支持<code>http:</code>、<code>https:</code>和<code>file:</code>三种协议。</p>
<p>另外，云配置文件本身也是可配置的，示例如下：</p>
<pre><code>tianma.play(&#39;http://www.example.com/config.js&#39;, {
    root: &#39;/home/user/htdocs/&#39;
});</code></pre>
<p>可以看到，以上配置文件允许用户自定义网站根目录。</p>
<h3 id="5.2">编写方法</h3>
<p>编写一个云配置文件和编写普通的天马配置文件类似，只是云配置文件中可以直接访问通过<code>play</code>方法传入的<code>config</code>对象，示例如下。</p>
<pre><code>var tianma = require(&#39;tianma&#39;),
    pipe = tianma.pipe;

tianma
    .createHost({ port: config.port || 80 })
        .mount(&#39;/&#39;, [
            pipe.static({ root: config.root || &#39;./htdocs&#39; })
        ])
        .start();</code></pre>
<p>以上云配置文件实现了一个静态服务器，允许用户自行配置服务器端口和网站根目录，并提供了默认配置项。</p>

<h2 id="6">SSL证书</h2>
<p>搭建HTTPS服务器时需要为提供服务的域名配置SSL证书。天马不但简化了自制证书的制作过程，也简化了证书的配置方式。</p>
<h3 id="6.1">证书制作</h3>
<p>如果还没有从颁发机构购买证书，或者因各种原因得不到生产环境使用的证书，至少在开发环境下可以自己做一个。天马命令行工具封装了OpenSSL，可以简单制作出某个域名用的公钥和私钥。以下是为<code>www.example.com</code>域名制作证书的一个示例。</p>
<pre><code>$ tianma ca www.example.com
create: www.example.com.cer
create: www.example.com.key

..done</code></pre>
<h4 id="6.1.1">安装根证书</h4>
<p>使用<code>tianma ca</code>命令制作的证书都基于天马根证书颁发，为了避免使用自制证书时遭遇浏览器安全警告，需要在浏览器中安装天马根证书。使用<code>tianma deploy</code>命令部署一个工作目录后，天马根证书位于<code>certificates/tianma.cer</code>，请按照以下说明安装。</p>
<ul>
<li><p>IE</p>
<p>  双击<code>tianma.cer</code>，在弹出的对话框中选择<code>安装证书</code>，证书安装位置手动指定为<code>受信任的根证书颁发机构</code>，完成。</p>
</li>
<li><p>Chrome</p>
<p>  Windows系统下Chrome与IE共用一套证书系统，只需完成IE的安装步骤即可。*nix系统下按照<code>设置</code> -&gt; <code>显示高级设置</code> -&gt; <code>管理证书</code>的顺序打开对话框后，按照类似IE下的步骤安装根证书。</p>
</li>
<li><p>Firefox</p>
<p>  按照<code>选项</code> -&gt; <code>高级</code> -&gt; <code>加密</code> -&gt; <code>查看证书</code> -&gt; <code>认证</code> -&gt; <code>导入</code>的顺序，打开<code>tianma.cer</code>之后，在弹出的对话框中勾选上<code>使用该证书认证网站</code>，完成。</p>
</li>
<li><p>其它浏览器</p>
<p>  依葫芦画瓢吧。</p>
</li>
</ul>
<h4 id="6.1.2">安装OpenSSL</h4>
<p>一般*nix系统下自带OpenSSL，而Windows系统木有。运行<code>tianma ca</code>命令时如果提示要先安装OpenSSL时，Windows用户可以在以下位置找到合适的安装包。</p>
<blockquote>
<p>   <a href="http://slproweb.com/products/Win32OpenSSL.html">http://slproweb.com/products/Win32OpenSSL.html</a></p>
</blockquote>
<p>之后按以下步骤安装。</p>
<ol>
<li><p>根据系统是32位还是64位，分别下载和安装<code>Visual C++ 2008 Redistributables / Visual C++ 2008 Redistributables (x64)</code>以及<code>Win32 OpenSSL v1.0.1c / Win64 OpenSSL v1.0.1c</code>。</p>
</li>
<li><p>按照<code>我的电脑</code> -&gt; <code>右键</code> -&gt; <code>属性</code> -&gt; <code>高级</code> -&gt; <code>环境变量</code>的顺序打开环境变量设置对话框。</p>
</li>
<li><p>假设默认安装到了<code>C:\OpenSSL-Win32</code>，把<code>C:\OpenSSL-Win32\bin</code>目录添加到PATH环境变量末尾，不同目录之间使用<code>;</code>分隔。</p>
</li>
<li><p>新增一个环境变量<code>OPENSSL_CONF</code>，设置为<code>C:\OpenSSL-Win32\bin\openssl.cfg</code>。</p>
</li>
<li><p>重启系统生效。</p>
</li>
</ol>
<h3 id="6.2">SNI</h3>
<p>天马服务器支持SNI技术，可以根据HTTPS请求使用的域名动态返回相应的证书，因此可以在一台服务器上使用多个域名提供不同服务。该功能使用简单，只要把每个域名的公钥和私钥文件放在工作目录下的<code>certificates/</code>子目录中，并让文件名与域名相同即可。例如有以下工作目录。</p>
<pre><code>- /home/user/www/
    - certificates/
        www.example.com.cer
        www.example.com.key
    config.js</code></pre>
<p>并且<code>config.js</code>内容如下。</p>
<pre><code>require(&#39;tianma&#39;)
    .createHost({ portssl: 443 })
        .mount(&#39;www.example.com&#39;, [])
        .start();</code></pre>
<p>启动服务后，当HTTPS请求使用<code>www.example.com</code>这个域名时，服务器会自动使用<code>certificates/</code>目录下对应的证书提供服务。</p>
<h4 id="6.2.1">降级方案</h4>
<p>Wndows XP系统下的IE不支持SNI技术，如果要解决这部分浏览器的证书问题的话，有以下两个方案：</p>
<ul>
<li><p>放弃SNI，只使用一个域名提供服务，并在创建主机时直接使用<code>cert</code>和<code>key</code>字段指定域名证书。</p>
</li>
<li><p>如果只想在开发或测试环境不让IE弹出证书安全警告的话，按照<code>Internet选项</code> -&gt; <code>高级</code> -&gt; <code>安全</code> -&gt; <code>对无效站点证书发出警告</code>的顺序把勾选框去掉。</p>
</li>
</ul>

</article>
<footer>
<p>© 2011-2014 Alibaba.com, Inc.</p>

</footer>
<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-48219354-1', 'nqdeng.github.io');
  ga('send', 'pageview');
</script>
</body>
</html>
